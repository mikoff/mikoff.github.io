<!doctype html><html lang=en><head><title>Uncertainty propagation with and without Lie groups · Aleksandr Mikoff's blog
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Aleksandr Mikoff"><meta name=description content="Uncertainty propagation with and without Lie groups and algebras Link to heading The correct uncertainty estimation of the pose is crucial for any navigation or positioning algorithm performance. One of the most natural way of representing the uncertainty for me is the confidence ellipse.
In the following post I would like to show effect of the uncertainty propagation using the various algorithms. What&rsquo;s more important, I would like to show the Gaussians representations both in cartesian and exponential coordinates."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Uncertainty propagation with and without Lie groups"><meta name=twitter:description content="Uncertainty propagation with and without Lie groups and algebras Link to heading The correct uncertainty estimation of the pose is crucial for any navigation or positioning algorithm performance. One of the most natural way of representing the uncertainty for me is the confidence ellipse.
In the following post I would like to show effect of the uncertainty propagation using the various algorithms. What&rsquo;s more important, I would like to show the Gaussians representations both in cartesian and exponential coordinates."><meta property="og:title" content="Uncertainty propagation with and without Lie groups"><meta property="og:description" content="Uncertainty propagation with and without Lie groups and algebras Link to heading The correct uncertainty estimation of the pose is crucial for any navigation or positioning algorithm performance. One of the most natural way of representing the uncertainty for me is the confidence ellipse.
In the following post I would like to show effect of the uncertainty propagation using the various algorithms. What&rsquo;s more important, I would like to show the Gaussians representations both in cartesian and exponential coordinates."><meta property="og:type" content="article"><meta property="og:url" content="https://mikoff.github.io/posts/uncertainty-propagation.md/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-04T23:00:00+03:00"><meta property="article:modified_time" content="2021-11-04T23:00:00+03:00"><link rel=canonical href=https://mikoff.github.io/posts/uncertainty-propagation.md/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.577e3c5ead537873430da16f0964b754a120fd87c4e2203a00686e7c75b51378.css integrity="sha256-V348Xq1TeHNDDaFvCWS3VKEg/YfE4iA6AGhufHW1E3g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/image.min.c1a5dfc6bac0eb1b85bcd8abf8aba0d18e0bf02fc972f9a0b17d2962f5ca8dd5.css integrity="sha256-waXfxrrA6xuFvNir+Kug0Y4L8C/JcvmgsX0pYvXKjdU=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/spoiler.min.bf901294afff95f520a8150a4df4249576eb9c49c4f40f5f9c2de750588dd594.css integrity="sha256-v5ASlK//lfUgqBUKTfQklXbrnEnE9A9fnC3nUFiN1ZQ=" crossorigin=anonymous media=screen><link rel=stylesheet href=/plugins/academic-icons/css/academicons.min.f6abb61f6b9b2e784eba22dfb93cd399ce30ee01825791830a2737d6bfcd2be9.css integrity="sha256-9qu2H2ubLnhOuiLfuTzTmc4w7gGCV5GDCic31r/NK+k=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://mikoff.github.io/>Aleksandr Mikoff's blog
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Posts</a></li><li class=navigation-item><a class=navigation-link href=/tags>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://mikoff.github.io/posts/uncertainty-propagation.md/>Uncertainty propagation with and without Lie groups</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2021-11-04T23:00:00+03:00>November 4, 2021
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
19-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/lie-algebra/>Lie Algebra</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/lie-group/>Lie Group</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/uncertainty-propagation/>Uncertainty Propagation</a></span></div></div></header><div class=post-content><h1 id=uncertainty-propagation-with-and-without-lie-groups-and-algebras>Uncertainty propagation with and without Lie groups and algebras
<a class=heading-link href=#uncertainty-propagation-with-and-without-lie-groups-and-algebras><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>The correct uncertainty estimation of the pose is crucial for any navigation or positioning algorithm performance. One of the most natural way of representing the uncertainty for me is the confidence ellipse.</p><p>In the following post I would like to show effect of the uncertainty propagation using the various algorithms. What&rsquo;s more important, I would like to show the Gaussians representations both in cartesian and exponential coordinates.</p><h2 id=small-lie-notes>Small Lie notes
<a class=heading-link href=#small-lie-notes><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>These notes are made for myself and summarize the info from Joan Sola paper &ldquo;A Micro Lie Theory&rdquo;<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and Barfoot&rsquo;s &ldquo;State estimation for robotics&rdquo;<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><h3 id=notation>Notation
<a class=heading-link href=#notation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li>Lie group $\mathcal{M}$ - a smooth manifold whose elements satisfy four group axioms: closure, identity, inverse and associativity. The manifold looks the same at its every point (no spikes, edges, etc.), thus all tangent spaces at any point are similar and have the same structure.</li><li>Group <em>compositions</em> and <em>actions</em>.<ul><li>Given group elements $\mathcal{X}, \mathcal{Y} \in \mathcal{M}$ there is a composition $\circ$, that gives the compositions of group elements $\mathcal{X}, \mathcal{Y}$ that also lies on the manifold. There is one special element of the group, that is called identity element $\mathcal{E}$. The composition of any other group element $\mathcal{Z}$ with $\mathcal{E}$ produces $\mathcal{Z}$: $\forall \mathcal{Z} \in \mathcal{M} : \mathcal{E} \circ \mathcal{Z} = \mathcal{Z} \circ \mathcal{E} = \mathcal{Z}$</li><li>Given group element $\mathcal{X}$ and some other set $\mathcal{v}$, $\mathcal{X}\cdot \mathcal{v}$ is the action of $\mathcal{X}$ on $\mathcal{v}$. For example, for $SO(3)$ group its action on vector is rotation: $\mathbf{R}\cdot\mathbf{x} = \mathbf{R}\mathbf{x}$, for $SE(3)$ the action is the rotation plus translation: $\mathbf{H}\cdot\mathbf{x} = \mathbf{R}\mathbf{x} + \mathbf{t}$.</li></ul></li><li>Lie algebra $\mathcal{m} = \mathcal{T}_{\mathcal{E}} \mathcal{M}$. It is the tangent space to $\mathcal{M}$ at the identity element. The beaty of $\mathcal{m}$ is that it is a vector space and we can use the standard machinery for it. Lie algebras can be defined to any group element $\mathcal{X}$, they can be viewed as local tangent spaces $\mathcal{T}_{\mathcal{X}}\mathcal{M}$, having vectors in its local coordinates.</li><li>Lie algebra elements $\tau$:<ul><li>Can be identified as vectors in $\mathcal{R}^n$, where $n$ is the number degrees of freedom of group $\mathcal{M}$.</li><li>Explicitly denoted with a hat decorator: $\wedge: \mathbf{R}^n \to \mathcal{m}$.</li><li>Represented as $n$-length vectors, such operation is usally encoded with $\vee: \mathcal{m} \to \mathbf{R}^n $ symbol.</li></ul></li><li>The exponential map, generally known as <em>retraction</em>, $\exp$ allows to convert elements of Lie algebra $\mathcal{m}$ into elements of Lie group $\mathcal{M}$: $\exp: \mathcal{m} \to \mathcal{M}$. It is an exact conversion.<br>The capitalized $Exp$ is used to denote $\mathbf{R}^n \to \mathcal{M}$ conversion.</li><li>The logarithm map $\log: \mathcal{M} \to \mathcal{m}$ allows to go vice versa.</li><li>Adjoint of $\mathcal{m}$. Vectors of the tangent space at element $\mathcal{X}$ can be transformed to the tangent space at $\mathcal{E}$ through a <em>adjoint</em> transform, that is linear: $ad: \mathcal{T}_{\mathcal{X}}\mathcal{M} \to \mathcal{T}_{\mathcal{E}}\mathcal{M}$.</li><li>Adjoint of $\mathcal{M}$. The representations of a given group element $\mathcal{X}$ at the $\mathcal{T}_{\mathcal{E}}\mathcal{M}$ vector space: $Ad$:<br>$Ad_{\mathcal{X}} = {}^\mathcal{E}\tau^{\wedge} = \mathcal{X}~{}^\mathcal{X}\tau^{\wedge}\mathcal{X}^{-1}$.<br>The adjoint is linear and homomorphic.
There is also adjoint matrix:<br>$\mathbf{Ad}_\mathcal{X}: \mathbf{R}^n \to \mathbf{R}^n;~{}^\mathcal{X}\tau \mapsto {}^\mathcal{E}\tau = \mathbf{Ad}_\mathcal{X} {}^\mathcal{X}\tau$.</li><li>Plus $\oplus$ and minus $\ominus$ operators: the combination of $Exp$ or $Log$ operator with one composition.<ul><li>There is a right operator, where $^\mathcal{X}\tau$ belongs to the tangent space $\mathcal{T}_{\mathcal{X}}\mathcal{M}$. It is said that ${}^\mathcal{X}\tau$ is expressed in <em>local</em> frame at $\mathcal{X}$:<br>$\mathcal{Y} = \mathcal{X} \oplus {}^\mathcal{X}\tau = \mathcal{X} \circ Exp({}^\mathcal{X}\mathcal{\tau}) \in \mathcal{M}$<br>${}^\mathcal{X}\tau = \mathcal{Y} \ominus \mathcal{X} = Log(\mathcal{X}^{-1}\circ\mathcal{Y}) \in \mathcal{T}_{\mathcal{X}}\mathcal{M}$</li><li>In the left operator $Exp({}^\mathcal{E}\mathcal{\tau})$ is on the left meaning that ${}^\mathcal{E}\mathcal{\tau}$ expressed in <em>global</em> frame:
$\mathcal{Y} = {}^\mathcal{E}\tau \oplus \mathcal{X} = Exp({}^\mathcal{E}\mathcal{\tau}) \circ \mathcal{X} \in \mathcal{M}$<br>${}^\mathcal{E}\tau = \mathcal{Y} \ominus \mathcal{X} = Log(\mathcal{Y}\circ\mathcal{X}^{-1}) \in \mathcal{T}_{\mathcal{E}}\mathcal{M}$<br>The choice of left or right operator specifies the perturbation frame: they can be defined globally or locally.</li></ul></li></ul><h3 id=uncertainty-on-manifolds>Uncertainty on manifolds
<a class=heading-link href=#uncertainty-on-manifolds><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>If there is a local perturbation $\mathcal{\tau}$ near the operation point $\bar{\mathcal{X}} \in \mathcal{M}$ in the tangent vector space $\mathcal{T}_{\bar{\mathcal{X}}}\mathcal{M}$, that can be defined as:</p>$$
\mathcal{X} = \bar{\mathcal{X}}\oplus\tau,~~~ \tau = \mathcal{X}\ominus\bar{\mathcal{X}} \in \mathcal{T}_{\bar{\mathcal{X}}}\mathcal{M},
$$<p>the covariances matrices can be properly defined on tangent space through standard expectation:</p>$$
\Sigma_{\mathcal{X}} = \mathbf{E}\left[\tau \tau ^T \right] \in \mathbf{R}^{n\times n}
$$<p>If we work with perturbations, expressed in global reference frame, then:</p>$$
\mathcal{X} = \tau\oplus\bar{\mathcal{X}},~~~ \tau = \mathcal{X}\ominus\bar{\mathcal{X}} \in \mathcal{T}_{\mathcal{E}}\mathcal{M}
$$<p>If we want to propagate the covariance through $f : \mathcal{M} \to \mathcal{N}; \mathcal{X}\mapsto\mathcal{Y} = f(\mathcal{X})$, we have to linearize:</p>$$
\Sigma_{\mathcal{Y}} \approx \frac{Df}{D\mathcal{X}}\Sigma_{\mathcal{X}}\frac{Df}{D\mathcal{X}}^T.
$$<h3 id=so3-and-se3>SO(3) and SE(3)
<a class=heading-link href=#so3-and-se3><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Lie group composition operator for SO(3) and SE(3) is just a matrix multiplication.</p><h3 id=plotting-utilities>Plotting utilities
<a class=heading-link href=#plotting-utilities><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><div class=spoiler><span class=spoilerText>Spoiler</span>
<input class=spoilerChecked type=checkbox showtext=Code><div class=spoilerContent><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>import</span> numpy <span style=color:#fff;font-weight:700>as</span> np
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>import</span> matplotlib.pylab <span style=color:#fff;font-weight:700>as</span> plt
</span></span><span style=display:flex><span>np.set_printoptions(precision=<span style=color:#ff0;font-weight:700>3</span>, suppress=<span style=color:#fff;font-weight:700>True</span>, linewidth=<span style=color:#ff0;font-weight:700>120</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>%matplotlib inline
</span></span><span style=display:flex><span>%config InlineBackend.figure_format=<span style=color:#0ff;font-weight:700>&#39;retina&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>def</span> density_scatter(x , y, ax = <span style=color:#fff;font-weight:700>None</span>, fig = <span style=color:#fff;font-weight:700>None</span>, sort = <span style=color:#fff;font-weight:700>True</span>, bins = <span style=color:#ff0;font-weight:700>20</span>, cbar=<span style=color:#fff;font-weight:700>True</span>, **kwargs ):
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>from</span> matplotlib <span style=color:#fff;font-weight:700>import</span> cm
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>from</span> matplotlib.colors <span style=color:#fff;font-weight:700>import</span> Normalize 
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>from</span> scipy.interpolate <span style=color:#fff;font-weight:700>import</span> interpn
</span></span><span style=display:flex><span>    <span style=color:#0ff;font-weight:700>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#0ff;font-weight:700>    Scatter plot colored by 2d histogram
</span></span></span><span style=display:flex><span><span style=color:#0ff;font-weight:700>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> ax is <span style=color:#fff;font-weight:700>None</span> :
</span></span><span style=display:flex><span>        fig , ax = plt.subplots()
</span></span><span style=display:flex><span>    data, x_e, y_e = np.histogram2d(x, y, bins = bins, density = <span style=color:#fff;font-weight:700>False</span> )
</span></span><span style=display:flex><span>    z = interpn((<span style=color:#ff0;font-weight:700>0.5</span>*(x_e[<span style=color:#ff0;font-weight:700>1</span>:] + x_e[:-<span style=color:#ff0;font-weight:700>1</span>]), <span style=color:#ff0;font-weight:700>0.5</span>*(y_e[<span style=color:#ff0;font-weight:700>1</span>:]+y_e[:-<span style=color:#ff0;font-weight:700>1</span>]) ), data ,np.vstack([x,y]).T , method = <span style=color:#0ff;font-weight:700>&#34;splinef2d&#34;</span>, bounds_error = <span style=color:#fff;font-weight:700>False</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>#To be sure to plot all data</span>
</span></span><span style=display:flex><span>    z[np.where(np.isnan(z))] = <span style=color:#ff0;font-weight:700>0.0</span>
</span></span><span style=display:flex><span>    z = z / np.sum(z)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#007f7f># Sort the points by density, so that the densest points are plotted last</span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> sort :
</span></span><span style=display:flex><span>        idx = z.argsort()
</span></span><span style=display:flex><span>        x, y, z = x[idx], y[idx], z[idx]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    sc = ax.scatter( x, y, c=z, marker=<span style=color:#0ff;font-weight:700>&#39;.&#39;</span>, s=<span style=color:#ff0;font-weight:700>1.0</span>, **kwargs )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> cbar:
</span></span><span style=display:flex><span>        norm = Normalize(vmin = np.min(z), vmax = np.max(z))
</span></span><span style=display:flex><span>        cbar = fig.colorbar(cm.ScalarMappable(norm = norm, **kwargs), ax=ax)
</span></span><span style=display:flex><span>        cbar.ax.set_ylabel(<span style=color:#0ff;font-weight:700>&#39;Density&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    levels = [<span style=color:#ff0;font-weight:700>0.5</span>, <span style=color:#ff0;font-weight:700>0.75</span>, <span style=color:#ff0;font-weight:700>0.9</span>]
</span></span><span style=display:flex><span>    H, X, Y = data, x_e, y_e
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> <span style=color:#fff;font-weight:700>True</span>:
</span></span><span style=display:flex><span>        <span style=color:#007f7f># Compute the density levels.</span>
</span></span><span style=display:flex><span>        Hflat = H.flatten()
</span></span><span style=display:flex><span>        inds = np.argsort(Hflat)[::-<span style=color:#ff0;font-weight:700>1</span>]
</span></span><span style=display:flex><span>        Hflat = Hflat[inds]
</span></span><span style=display:flex><span>        sm = np.cumsum(Hflat)
</span></span><span style=display:flex><span>        sm /= sm[-<span style=color:#ff0;font-weight:700>1</span>]
</span></span><span style=display:flex><span>        V = np.empty(<span style=color:#fff;font-weight:700>len</span>(levels))
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>for</span> i, v0 in <span style=color:#fff;font-weight:700>enumerate</span>(levels):
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>try</span>:
</span></span><span style=display:flex><span>                V[i] = Hflat[sm &lt;= v0][-<span style=color:#ff0;font-weight:700>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>except</span> IndexError:
</span></span><span style=display:flex><span>                V[i] = Hflat[<span style=color:#ff0;font-weight:700>0</span>]
</span></span><span style=display:flex><span>        V.sort()
</span></span><span style=display:flex><span>        m = np.diff(V) == <span style=color:#ff0;font-weight:700>0</span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> np.any(m) and not quiet:
</span></span><span style=display:flex><span>            logging.warning(<span style=color:#0ff;font-weight:700>&#34;Too few points to create valid contours&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>while</span> np.any(m):
</span></span><span style=display:flex><span>            V[np.where(m)[<span style=color:#ff0;font-weight:700>0</span>][<span style=color:#ff0;font-weight:700>0</span>]] *= <span style=color:#ff0;font-weight:700>1.0</span> - <span style=color:#ff0;font-weight:700>1e-4</span>
</span></span><span style=display:flex><span>            m = np.diff(V) == <span style=color:#ff0;font-weight:700>0</span>
</span></span><span style=display:flex><span>        V.sort()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007f7f># Compute the bin centers.</span>
</span></span><span style=display:flex><span>        X1, Y1 = <span style=color:#ff0;font-weight:700>0.5</span> * (X[<span style=color:#ff0;font-weight:700>1</span>:] + X[:-<span style=color:#ff0;font-weight:700>1</span>]), <span style=color:#ff0;font-weight:700>0.5</span> * (Y[<span style=color:#ff0;font-weight:700>1</span>:] + Y[:-<span style=color:#ff0;font-weight:700>1</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007f7f># Extend the array for the sake of the contours at the plot edges.</span>
</span></span><span style=display:flex><span>        H2 = H.min() + np.zeros((H.shape[<span style=color:#ff0;font-weight:700>0</span>] + <span style=color:#ff0;font-weight:700>4</span>, H.shape[<span style=color:#ff0;font-weight:700>1</span>] + <span style=color:#ff0;font-weight:700>4</span>))
</span></span><span style=display:flex><span>        H2[<span style=color:#ff0;font-weight:700>2</span>:-<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>2</span>:-<span style=color:#ff0;font-weight:700>2</span>] = H
</span></span><span style=display:flex><span>        H2[<span style=color:#ff0;font-weight:700>2</span>:-<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>1</span>] = H[:, <span style=color:#ff0;font-weight:700>0</span>]
</span></span><span style=display:flex><span>        H2[<span style=color:#ff0;font-weight:700>2</span>:-<span style=color:#ff0;font-weight:700>2</span>, -<span style=color:#ff0;font-weight:700>2</span>] = H[:, -<span style=color:#ff0;font-weight:700>1</span>]
</span></span><span style=display:flex><span>        H2[<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>2</span>:-<span style=color:#ff0;font-weight:700>2</span>] = H[<span style=color:#ff0;font-weight:700>0</span>]
</span></span><span style=display:flex><span>        H2[-<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>2</span>:-<span style=color:#ff0;font-weight:700>2</span>] = H[-<span style=color:#ff0;font-weight:700>1</span>]
</span></span><span style=display:flex><span>        H2[<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>1</span>] = H[<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>0</span>]
</span></span><span style=display:flex><span>        H2[<span style=color:#ff0;font-weight:700>1</span>, -<span style=color:#ff0;font-weight:700>2</span>] = H[<span style=color:#ff0;font-weight:700>0</span>, -<span style=color:#ff0;font-weight:700>1</span>]
</span></span><span style=display:flex><span>        H2[-<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>1</span>] = H[-<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>0</span>]
</span></span><span style=display:flex><span>        H2[-<span style=color:#ff0;font-weight:700>2</span>, -<span style=color:#ff0;font-weight:700>2</span>] = H[-<span style=color:#ff0;font-weight:700>1</span>, -<span style=color:#ff0;font-weight:700>1</span>]
</span></span><span style=display:flex><span>        X2 = np.concatenate(
</span></span><span style=display:flex><span>            [
</span></span><span style=display:flex><span>                X1[<span style=color:#ff0;font-weight:700>0</span>] + np.array([-<span style=color:#ff0;font-weight:700>2</span>, -<span style=color:#ff0;font-weight:700>1</span>]) * np.diff(X1[:<span style=color:#ff0;font-weight:700>2</span>]),
</span></span><span style=display:flex><span>                X1,
</span></span><span style=display:flex><span>                X1[-<span style=color:#ff0;font-weight:700>1</span>] + np.array([<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>2</span>]) * np.diff(X1[-<span style=color:#ff0;font-weight:700>2</span>:]),
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        Y2 = np.concatenate(
</span></span><span style=display:flex><span>            [
</span></span><span style=display:flex><span>                Y1[<span style=color:#ff0;font-weight:700>0</span>] + np.array([-<span style=color:#ff0;font-weight:700>2</span>, -<span style=color:#ff0;font-weight:700>1</span>]) * np.diff(Y1[:<span style=color:#ff0;font-weight:700>2</span>]),
</span></span><span style=display:flex><span>                Y1,
</span></span><span style=display:flex><span>                Y1[-<span style=color:#ff0;font-weight:700>1</span>] + np.array([<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>2</span>]) * np.diff(Y1[-<span style=color:#ff0;font-weight:700>2</span>:]),
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        ax.contour(X2, Y2, H2.T, V, alpha = <span style=color:#ff0;font-weight:700>0.5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> ax
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>def</span> vis_distribution(fig, ax, mean, cov, transform, N = <span style=color:#ff0;font-weight:700>10000</span>):
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>from</span> collections <span style=color:#fff;font-weight:700>import</span> Iterable
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    samples = np.random.multivariate_normal(mean=np.zeros(<span style=color:#ff0;font-weight:700>6</span>), cov=Sigma_next, size=N).T
</span></span><span style=display:flex><span>    samples_se3 = np.zeros((N, <span style=color:#ff0;font-weight:700>2</span>))
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>for</span> i, s in <span style=color:#fff;font-weight:700>enumerate</span>(samples.T):
</span></span><span style=display:flex><span>        sample_se3 = transform @ SE3.exp(s)
</span></span><span style=display:flex><span>        samples_se3[i, <span style=color:#ff0;font-weight:700>0</span>] = sample_se3[<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>3</span>]
</span></span><span style=display:flex><span>        samples_se3[i, <span style=color:#ff0;font-weight:700>1</span>] = sample_se3[<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>3</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> <span style=color:#fff;font-weight:700>isinstance</span>(ax, Iterable):
</span></span><span style=display:flex><span>        ax1, ax2 = ax
</span></span><span style=display:flex><span>        density_scatter(samples[<span style=color:#ff0;font-weight:700>0</span>, :], samples[<span style=color:#ff0;font-weight:700>1</span>, :], ax1, fig, cmap=plt.cm.cool, cbar = <span style=color:#fff;font-weight:700>False</span>)
</span></span><span style=display:flex><span>        ax1.set(xlabel = <span style=color:#0ff;font-weight:700>&#39;x, meters&#39;</span>, ylabel = <span style=color:#0ff;font-weight:700>&#39;y, meters&#39;</span>)
</span></span><span style=display:flex><span>        ax1.axis(<span style=color:#0ff;font-weight:700>&#39;equal&#39;</span>)
</span></span><span style=display:flex><span>        ax2.set(xlabel = <span style=color:#0ff;font-weight:700>&#39;x, meters&#39;</span>, ylabel = <span style=color:#0ff;font-weight:700>&#39;y, meters&#39;</span>)
</span></span><span style=display:flex><span>        ax1.set_title(<span style=color:#0ff;font-weight:700>&#39;Uncertainty at tangent space, $\mathfrak </span><span style=color:#0ff;font-weight:700>{g}</span><span style=color:#0ff;font-weight:700>$&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>else</span>:
</span></span><span style=display:flex><span>        ax2 = ax
</span></span><span style=display:flex><span>    density_scatter(samples_se3[:,<span style=color:#ff0;font-weight:700>0</span>], samples_se3[:,<span style=color:#ff0;font-weight:700>1</span>], ax2, fig, cmap=plt.cm.cool, cbar = <span style=color:#fff;font-weight:700>False</span>)
</span></span><span style=display:flex><span>    meanse3 = np.mean(samples_se3, axis = <span style=color:#ff0;font-weight:700>0</span>)
</span></span><span style=display:flex><span>    ax2.scatter([meanse3[<span style=color:#ff0;font-weight:700>0</span>]], [meanse3[<span style=color:#ff0;font-weight:700>1</span>]], marker = <span style=color:#0ff;font-weight:700>&#39;x&#39;</span>, s = <span style=color:#ff0;font-weight:700>150</span>, c = <span style=color:#0ff;font-weight:700>&#39;black&#39;</span>)
</span></span><span style=display:flex><span>    ax2.set(xlabel = <span style=color:#0ff;font-weight:700>&#39;x, meters&#39;</span>, ylabel = <span style=color:#0ff;font-weight:700>&#39;y, meters&#39;</span>)
</span></span><span style=display:flex><span>    ax2.axis(<span style=color:#0ff;font-weight:700>&#39;equal&#39;</span>)
</span></span><span style=display:flex><span>    ax2.set_title(<span style=color:#0ff;font-weight:700>&#39;Uncertainty at manifold, $\mathcal</span><span style=color:#0ff;font-weight:700>{G}</span><span style=color:#0ff;font-weight:700>$&#39;</span>)
</span></span></code></pre></div></div></div><h2 id=lie-algebras-and-groups-operations>Lie algebras and groups operations
<a class=heading-link href=#lie-algebras-and-groups-operations><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>First, let&rsquo;s define all the needed functions to operate on SO(3) and SE(3) groups using Lie algebras. In the code I explicitly specify the implemented equation&rsquo;s numbers from Barfoot&rsquo;s book on robotics. Here we will use the left-hand convention, that means that the state is expressed with respect to the moving, or robot perspective. Therefore the increments are represented in global coordinate frame and applied from the left side. Our $\mathbf{T}_{next} = \mathbf{T}_{bw}$, this matrix represents the transformation of the world w.r.t. the body: to plot the robot pose in global coordinate frame we have to invert it, to do so we find the transformation of the body w.r.t. the world: $\mathbf{T}_{wb}$</p><p>Written using the matrices operations we have:</p>$$
\mathbf{T}_{b_{i+1}w} = \mathbf{T}_{b_{i+1}b_{i}} \mathbf{T}_{b_{i}w}.
$$<p>It means that to we want to obtain the transformation of the world w.r.t. the body at time step $i+1$ we have to multiply:</p><ul><li>the transformation of the world w.r.t. the body at time step $i$ $-$ $\mathbf{T}_{b_{i}w}$;</li><li>with transformation increment of the body from time step $i$ to time step $i+1$ $-$ $\mathbf{T}_{b_{i+1}b_{i}}$.</li></ul><p>In this case our $\mathbf{T}_{b_{i+1}b_{i}}$ has trivial form, but the important note here is that its $(0, 0)$ elements has value $-1$, describing the pose of at time $i$ w.r.t. to the pose at time $i+1$, and equal to $[-1, 0, 0]^T$ if we move to the right (initially I found this $-1$ counter-intuitive).</p><p>Of course, this notation will be much more intuitive if we work with transform matrix $T_{wb}$, that represents the transform of the body w.r.t. world. In such a case we have:</p>$$
\mathbf{T}_{w b_{i+1}} = \mathbf{T}_{w b_{i}}\mathbf{T}_{b_{i}b_{i+1}},
$$<p>and our increment is equal to $1$, instead of $-1$. These differences are very important when we work with transformations and can lead to dramatic results when mixed order is used. The latter approach typically used in robotics and when we work with IMU, the former one (left) - in computer vision <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>, <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p><div class=spoiler><span class=spoilerText>Spoiler</span>
<input class=spoilerChecked type=checkbox showtext=Code><div class=spoilerContent><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#fff;font-weight:700>from</span> abc <span style=color:#fff;font-weight:700>import</span> ABC, abstractmethod
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>import</span> numpy <span style=color:#fff;font-weight:700>as</span> np
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> LieGroup(ABC):
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    @abstractmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> wedge(tau):
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>pass</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    @abstractmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> exp(tau):
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>pass</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    @abstractmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> log(T):
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>pass</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    @abstractmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> Ad(tau):
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>pass</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> SO3(LieGroup):
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> wedge(phi):
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#39;&#39;&#39;B. eq. (7.10)&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        e1, e2, e3 = np.squeeze(phi)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> np.array([[<span style=color:#ff0;font-weight:700>0.</span>, -e3, e2],
</span></span><span style=display:flex><span>                         [e3, <span style=color:#ff0;font-weight:700>0.</span>, -e1],
</span></span><span style=display:flex><span>                         [-e2, e1, <span style=color:#ff0;font-weight:700>0.</span>]])
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> exp(phi):
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#39;&#39;&#39;B. eq. (7.23)&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> np.linalg.norm(phi) &lt; <span style=color:#ff0;font-weight:700>1e-8</span>:
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> np.eye(<span style=color:#ff0;font-weight:700>3</span>) + SO3.wedge(phi)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>else</span>:
</span></span><span style=display:flex><span>            norm = np.linalg.norm(phi)
</span></span><span style=display:flex><span>            a = phi / norm
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> np.cos(norm) * np.eye(<span style=color:#ff0;font-weight:700>3</span>) + (<span style=color:#ff0;font-weight:700>1.0</span> - np.cos(norm)) * np.outer(a, a.T) + np.sin(norm) * SO3.wedge(a)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> Ad(phi):
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> SO3.exp(phi)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> log(R):
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#39;&#39;&#39;B. eq. (7.28)&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        phi = np.arccos((np.trace(R) - <span style=color:#ff0;font-weight:700>1.0</span>) / <span style=color:#ff0;font-weight:700>2.0</span>)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> phi ** <span style=color:#ff0;font-weight:700>2</span> &lt; <span style=color:#ff0;font-weight:700>1e-8</span>:
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> np.zeros(<span style=color:#ff0;font-weight:700>3</span>)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>else</span>:
</span></span><span style=display:flex><span>            w = (phi / (<span style=color:#ff0;font-weight:700>2.</span> * np.sin(phi))) * (R - R.T)
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> np.array([[w[<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>1</span>]], [w[<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>2</span>]], [w[<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>0</span>]]])
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> inv(R):
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> R.T[:,:]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> J(phi):
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#39;&#39;&#39;B. eq. (7.37a), left Jacobian of SO3&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> np.linalg.norm(phi) &lt; <span style=color:#ff0;font-weight:700>1e-8</span>:
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> np.eye(<span style=color:#ff0;font-weight:700>3</span>) + <span style=color:#ff0;font-weight:700>0.5</span> * SO3.wedge(phi)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>else</span>:
</span></span><span style=display:flex><span>            norm = np.linalg.norm(phi)
</span></span><span style=display:flex><span>            a = phi / norm
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> np.sin(norm) / norm * np.eye(<span style=color:#ff0;font-weight:700>3</span>) + (<span style=color:#ff0;font-weight:700>1.0</span> - np.sin(norm)/norm) * np.outer(a, a.T)\
</span></span><span style=display:flex><span>                + (<span style=color:#ff0;font-weight:700>1.0</span> - np.cos(norm)) / norm * SO3.wedge(a)
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> J_inv(phi):
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#39;&#39;&#39;B. eq. (7.37b), J^{-1}&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> np.linalg.norm(phi) &lt; <span style=color:#ff0;font-weight:700>1e-8</span>:
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> np.eye(<span style=color:#ff0;font-weight:700>3</span>) - <span style=color:#ff0;font-weight:700>0.5</span> * SO3.wedge(phi)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>else</span>:
</span></span><span style=display:flex><span>            norm = np.linalg.norm(phi)
</span></span><span style=display:flex><span>            a = phi / norm
</span></span><span style=display:flex><span>            cotHalfP = <span style=color:#ff0;font-weight:700>1.</span> / np.tan(norm/<span style=color:#ff0;font-weight:700>2</span>)
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> norm / <span style=color:#ff0;font-weight:700>2</span> * cotHalfP * np.eye(<span style=color:#ff0;font-weight:700>3</span>) + (<span style=color:#ff0;font-weight:700>1.0</span> - norm/<span style=color:#ff0;font-weight:700>2</span> * cotHalfP) * np.outer(a, a.T)\
</span></span><span style=display:flex><span>                - norm/<span style=color:#ff0;font-weight:700>2</span> * SO3.wedge(a)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> SE3(LieGroup):
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> split_xi(xi):
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#39;&#39;&#39;return translational and rotational component, B. eq. (7.14)&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        xi = np.squeeze(xi)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> xi[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>], xi[<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> wedge(xi):
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#39;&#39;&#39;B. eq. (7.14)&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        t, phi = SE3.split_xi(xi)
</span></span><span style=display:flex><span>        wedge = np.zeros((<span style=color:#ff0;font-weight:700>4</span>,<span style=color:#ff0;font-weight:700>4</span>))
</span></span><span style=display:flex><span>        wedge[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>] = SO3.wedge(phi)
</span></span><span style=display:flex><span>        wedge[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>3</span>] = t
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> wedge
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> exp(xi):
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#39;&#39;&#39;B. eq. (7.44)&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        t, phi = SE3.split_xi(xi)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> np.linalg.norm(phi) &lt; <span style=color:#ff0;font-weight:700>1e-8</span>:
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> np.eye(<span style=color:#ff0;font-weight:700>4</span>) + SE3.wedge(xi)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>else</span>:
</span></span><span style=display:flex><span>            norm = np.linalg.norm(phi)
</span></span><span style=display:flex><span>            se3_wedge = SE3.wedge(xi)
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> np.eye(<span style=color:#ff0;font-weight:700>4</span>) + se3_wedge + (<span style=color:#ff0;font-weight:700>1.0</span> - np.cos(norm)) / norm ** <span style=color:#ff0;font-weight:700>2</span> * se3_wedge @ se3_wedge\
</span></span><span style=display:flex><span>                + (norm - np.sin(norm)) / norm ** <span style=color:#ff0;font-weight:700>3</span> * se3_wedge @ se3_wedge @ se3_wedge
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> Ad(xi):
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#39;&#39;&#39;B. eq. (7.45)&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> xi.shape == (<span style=color:#ff0;font-weight:700>4</span>, <span style=color:#ff0;font-weight:700>4</span>):
</span></span><span style=display:flex><span>            xi = SE3.log(xi)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        t, phi = SE3.split_xi(xi)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        C = SO3.exp(phi)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Tau = np.zeros((<span style=color:#ff0;font-weight:700>6</span>, <span style=color:#ff0;font-weight:700>6</span>))
</span></span><span style=display:flex><span>        Tau[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>] = Tau[<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>] = C
</span></span><span style=display:flex><span>        Tau[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>] = SO3.wedge(SO3.J(phi) @ t) @ C
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> Tau
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> log(T):
</span></span><span style=display:flex><span>        <span style=color:#0ff;font-weight:700>&#39;&#39;&#39;B. eq. (7.35)&#39;&#39;&#39;</span>
</span></span><span style=display:flex><span>        t = T[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>3</span>]
</span></span><span style=display:flex><span>        w = SO3.log(T[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007f7f># 7.35 p = invJ @ t</span>
</span></span><span style=display:flex><span>        p = SO3.J_inv(w) @ t
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> np.hstack((p.flatten(), w.flatten()))
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    @staticmethod
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>def</span> inv(T):
</span></span><span style=display:flex><span>        T_inv = np.eye(<span style=color:#ff0;font-weight:700>4</span>)
</span></span><span style=display:flex><span>        T_inv[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>] = T[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>].T
</span></span><span style=display:flex><span>        T_inv[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>3</span>] = - T_inv[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>] @ T[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>3</span>]
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> T_inv
</span></span></code></pre></div></div></div><h2 id=pose-compound-experiments>Pose compound experiments
<a class=heading-link href=#pose-compound-experiments><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Now assume that we have some initial pose and we are absolutely confident about it. Then we make 500 moves forward (right direction) and on each move we are absolutely confident about travelled distance (it is equal to 1 meter), but not so certain about direction, it&rsquo;s associated uncertainty is equal to $\sigma = 2 ^\circ$.</p><h3 id=monte-carlo>Monte-carlo
<a class=heading-link href=#monte-carlo><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>At first, let&rsquo;s directly simulate it. To do so we would like to generate 1000 sequences of 100 moves. On each move we are uncertain about our direction and therefore randomly draw the angle from the normal distribution.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#fff;font-weight:700>import</span> matplotlib.pylab <span style=color:#fff;font-weight:700>as</span> plt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>N_steps = <span style=color:#ff0;font-weight:700>500</span>
</span></span><span style=display:flex><span>step_directed, sigma_direction_rad = -<span style=color:#ff0;font-weight:700>1.0</span>, np.deg2rad(<span style=color:#ff0;font-weight:700>2.0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>P = <span style=color:#ff0;font-weight:700>1000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>coords = np.zeros((P, <span style=color:#ff0;font-weight:700>2</span>, N_steps))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> p in <span style=color:#fff;font-weight:700>range</span>(<span style=color:#ff0;font-weight:700>0</span>, P):
</span></span><span style=display:flex><span>    T_next = np.eye(<span style=color:#ff0;font-weight:700>4</span>)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>for</span> i in <span style=color:#fff;font-weight:700>range</span>(<span style=color:#ff0;font-weight:700>0</span>, N_steps):
</span></span><span style=display:flex><span>        <span style=color:#007f7f># perturb our motion</span>
</span></span><span style=display:flex><span>        T_move = SE3.exp([step_directed, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, np.random.normal(<span style=color:#ff0;font-weight:700>0.0</span>, sigma_direction_rad)])
</span></span><span style=display:flex><span>        <span style=color:#007f7f># move the particle</span>
</span></span><span style=display:flex><span>        T_next = T_move @ T_next
</span></span><span style=display:flex><span>        <span style=color:#007f7f># save the state</span>
</span></span><span style=display:flex><span>        coords[p, :,i] = np.linalg.inv(T_next)[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fig, ax = plt.subplots(<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>1</span>, figsize = (<span style=color:#ff0;font-weight:700>5</span>, <span style=color:#ff0;font-weight:700>5</span>))
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> p in <span style=color:#fff;font-weight:700>range</span>(<span style=color:#ff0;font-weight:700>0</span>, P):
</span></span><span style=display:flex><span>    ax.plot(coords[p, <span style=color:#ff0;font-weight:700>0</span>,:], coords[p, <span style=color:#ff0;font-weight:700>1</span>,:], c=<span style=color:#0ff;font-weight:700>&#39;b&#39;</span>, alpha=<span style=color:#ff0;font-weight:700>0.1</span>)
</span></span><span style=display:flex><span>ax.scatter(coords[:, <span style=color:#ff0;font-weight:700>0</span>, -<span style=color:#ff0;font-weight:700>1</span>], coords[:, <span style=color:#ff0;font-weight:700>1</span>, -<span style=color:#ff0;font-weight:700>1</span>], c=<span style=color:#0ff;font-weight:700>&#39;r&#39;</span>, s = <span style=color:#ff0;font-weight:700>2.0</span>)
</span></span><span style=display:flex><span>ax.axis(<span style=color:#0ff;font-weight:700>&#34;equal&#34;</span>)
</span></span><span style=display:flex><span>ax.set(xlabel = <span style=color:#0ff;font-weight:700>&#39;x, meters&#39;</span>, ylabel = <span style=color:#0ff;font-weight:700>&#39;y, meters&#39;</span>)
</span></span><span style=display:flex><span>ax.set_title(<span style=color:#0ff;font-weight:700>&#34;Monte-carlo simulation&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>print</span>(<span style=color:#0ff;font-weight:700>&#34;Mean:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, np.mean(coords[:, :, -<span style=color:#ff0;font-weight:700>1</span>], axis = <span style=color:#ff0;font-weight:700>0</span>))
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>print</span>(<span style=color:#0ff;font-weight:700>&#34;Covariance:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, np.cov(coords[:,:,-<span style=color:#ff0;font-weight:700>1</span>].T))
</span></span></code></pre></div><pre><code>Mean:
 [430.06    6.476]
Covariance:
 [[ 4857.184 -1585.499]
 [-1585.499 36559.492]]
</code></pre><p><img src=uncertainty_prop_12_1.png#center alt=png></p><p>After 100 steps we see famously known banana-shaped distribution, that <strong>can not</strong> be represented using gaussian distribution! But wait, in next subsection we will note that this &ldquo;banana&rdquo; <strong>can be</strong> described by Gaussian in our tangent space $\mathcal{T}_{\mathcal{X}}\mathcal{M}$ and mapped from vector tangent space to Lie group conveniently.</p><h3 id=first-order-approximation>First-order approximation
<a class=heading-link href=#first-order-approximation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Now let&rsquo;s first show the results of the covariance estimation using first-order method, where we throw away all Taylor expansion terms except the first one.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#007f7f># True pose on the first iteration</span>
</span></span><span style=display:flex><span>T_0_true = np.eye(<span style=color:#ff0;font-weight:700>4</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>T_move = np.array([[<span style=color:#ff0;font-weight:700>1.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>,  step_directed],
</span></span><span style=display:flex><span>                    [<span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>1.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>],
</span></span><span style=display:flex><span>                    [<span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>1.</span>, <span style=color:#ff0;font-weight:700>0.</span>],
</span></span><span style=display:flex><span>                    [<span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>1.</span>]])
</span></span><span style=display:flex><span>Sigma_move = np.diag([<span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, sigma_direction_rad**<span style=color:#ff0;font-weight:700>2</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>T_next = T_0_true
</span></span><span style=display:flex><span>Sigma_next = np.zeros((<span style=color:#ff0;font-weight:700>6</span>, <span style=color:#ff0;font-weight:700>6</span>))
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> _ in <span style=color:#fff;font-weight:700>range</span>(<span style=color:#ff0;font-weight:700>0</span>, N_steps):
</span></span><span style=display:flex><span>    T_next = T_move @ T_next 
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#007f7f># second-order term</span>
</span></span><span style=display:flex><span>    Ad_T1 = SE3.Ad(T_next)
</span></span><span style=display:flex><span>    Sigma_move_dash = Ad_T1 @ Sigma_move @ Ad_T1.T
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Sigma_next = Sigma_next + Sigma_move_dash
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>fig, ax = plt.subplots(<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>2</span>, figsize = (<span style=color:#ff0;font-weight:700>10</span>, <span style=color:#ff0;font-weight:700>5</span>))
</span></span><span style=display:flex><span>vis_distribution(fig, ax, np.zeros(<span style=color:#ff0;font-weight:700>6</span>), Sigma_next, np.linalg.inv(T_next), N = <span style=color:#ff0;font-weight:700>10000</span>)
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>print</span>(<span style=color:#0ff;font-weight:700>&#34;Covariance:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, Sigma_next[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>2</span>])
</span></span></code></pre></div><pre><code>&lt;ipython-input-1-14b40a8f213d&gt;:94: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated since Python 3.3, and in 3.10 it will stop working
  from collections import Iterable


Covariance:
 [[    0.       0.  ]
 [    0.   50921.98]]
</code></pre><p><img src=uncertainty_prop_15_2.png#center alt=png></p><p>When we closely look at these samples we immediately understand why it is beneficial to have the Gaussian in tangent space (Lie algebra elements) and then retract it to our manifold (Lie group elements - rotation matrices!). Doing so we note that the banana-shaped distribution is actually a Gaussian <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> and we can correctly represent the uncertainties and manipulate them!</p><p>However, we still observe the inaccuracies in our representation and what is more important: our uncertainty is underestimated and equal to zero along Y-coordinate axis. To improve the representation let&rsquo;s leverage the Taylor series even more and take into account higher order terms.</p><h3 id=unscented-transform>Unscented transform
<a class=heading-link href=#unscented-transform><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Now let&rsquo;s compound the poses, or move poses from first to last using unscented transform. This technique is often used when the nonlinear transformation of a probability distribution is required.</p><p>Its underlying idea is the following:</p><ul><li>Take a set of particles, or sigma points, from our prior distribution.</li><li>Apply the transform function $f$ to each point.</li><li>Calculate the mean and covariance of the transformed points statistically.</li></ul><p>Do we have any improvement? Let&rsquo;s check!</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>T_next = T_0_true
</span></span><span style=display:flex><span>Sigma_next = np.zeros((<span style=color:#ff0;font-weight:700>6</span>, <span style=color:#ff0;font-weight:700>6</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>L = <span style=color:#ff0;font-weight:700>12</span>
</span></span><span style=display:flex><span>kappa = <span style=color:#ff0;font-weight:700>1.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sigma_weights = np.zeros(<span style=color:#ff0;font-weight:700>2</span> * L + <span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>sigma_weights[<span style=color:#ff0;font-weight:700>0</span>] = kappa / (kappa + L)
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> i in <span style=color:#fff;font-weight:700>range</span>(<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#fff;font-weight:700>len</span>(sigma_weights)):
</span></span><span style=display:flex><span>    sigma_weights[i] = <span style=color:#ff0;font-weight:700>1.0</span> / (<span style=color:#ff0;font-weight:700>2</span> * kappa + <span style=color:#ff0;font-weight:700>2</span> * L)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> _ in <span style=color:#fff;font-weight:700>range</span>(<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>500</span>):
</span></span><span style=display:flex><span>    Sigma_total = np.zeros((<span style=color:#ff0;font-weight:700>12</span>, <span style=color:#ff0;font-weight:700>12</span>)) + np.eye(<span style=color:#ff0;font-weight:700>12</span>) * <span style=color:#ff0;font-weight:700>1e-9</span>
</span></span><span style=display:flex><span>    Sigma_total[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>6</span>, <span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>6</span>] += Sigma_next
</span></span><span style=display:flex><span>    Sigma_total[<span style=color:#ff0;font-weight:700>6</span>:<span style=color:#ff0;font-weight:700>12</span>, <span style=color:#ff0;font-weight:700>6</span>:<span style=color:#ff0;font-weight:700>12</span>] += Sigma_move
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    S = np.linalg.cholesky(Sigma_total)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sigma_points = np.zeros((L, <span style=color:#ff0;font-weight:700>2</span> * L + <span style=color:#ff0;font-weight:700>1</span>))
</span></span><span style=display:flex><span>    sigma_points[:, [<span style=color:#ff0;font-weight:700>0</span>]] = np.zeros((<span style=color:#ff0;font-weight:700>12</span>, <span style=color:#ff0;font-weight:700>1</span>))
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>for</span> i in <span style=color:#fff;font-weight:700>range</span>(<span style=color:#ff0;font-weight:700>0</span>, (sigma_points.shape[<span style=color:#ff0;font-weight:700>1</span>] - <span style=color:#ff0;font-weight:700>1</span>) // <span style=color:#ff0;font-weight:700>2</span>):
</span></span><span style=display:flex><span>        sigma_points[:, [<span style=color:#ff0;font-weight:700>1</span> + i]] = np.sqrt(L + kappa) * S[:,[i]]
</span></span><span style=display:flex><span>        sigma_points[:, [<span style=color:#ff0;font-weight:700>1</span> + i + L]] = -np.sqrt(L + kappa) * S[:,[i]]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    T_new = T_move @ T_next
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    xis = np.zeros((<span style=color:#ff0;font-weight:700>6</span>, <span style=color:#ff0;font-weight:700>2</span> * L + <span style=color:#ff0;font-weight:700>1</span>))
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>for</span> i in <span style=color:#fff;font-weight:700>range</span>(<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>2</span> * L + <span style=color:#ff0;font-weight:700>1</span>):
</span></span><span style=display:flex><span>        xi_next = sigma_points[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>6</span>, [i]]
</span></span><span style=display:flex><span>        xi_move = sigma_points[<span style=color:#ff0;font-weight:700>6</span>:<span style=color:#ff0;font-weight:700>12</span>, [i]]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        xis[:, i] = SE3.log(SE3.exp(xi_next) @ T_next @ SE3.exp(xi_move) @ T_move @ np.linalg.inv(T_new))
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    xis_mean = (sigma_weights @ xis.T).reshape((<span style=color:#ff0;font-weight:700>6</span>, <span style=color:#ff0;font-weight:700>1</span>))
</span></span><span style=display:flex><span>    xis_sigma = np.zeros((<span style=color:#ff0;font-weight:700>6</span>, <span style=color:#ff0;font-weight:700>6</span>))
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>for</span> i in <span style=color:#fff;font-weight:700>range</span>(<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>2</span> * L + <span style=color:#ff0;font-weight:700>1</span>):
</span></span><span style=display:flex><span>        cov = (xis[:,[i]] - xis_mean) @ (xis[:,[i]] - xis_mean).T
</span></span><span style=display:flex><span>        xis_sigma += sigma_weights[i] * cov
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    T_next = T_new
</span></span><span style=display:flex><span>    Sigma_next = xis_sigma
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>fig, ax = plt.subplots(<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>2</span>, figsize = (<span style=color:#ff0;font-weight:700>10</span>, <span style=color:#ff0;font-weight:700>5</span>))
</span></span><span style=display:flex><span>vis_distribution(fig, ax, np.zeros(<span style=color:#ff0;font-weight:700>6</span>), Sigma_next, np.linalg.inv(T_next), N = <span style=color:#ff0;font-weight:700>10000</span>)
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>print</span>(<span style=color:#0ff;font-weight:700>&#34;Covariance:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, Sigma_next[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>2</span>])
</span></span></code></pre></div><pre><code>Covariance:
 [[    0.        0.   ]
 [    0.    50617.404]]
</code></pre><p><img src=uncertainty_prop_18_1.png#center alt=png></p><p>Unfortunately, no, the covariance we end up with is the same as for previous method. As noted in <sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>, <sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>, such representation of the mean is valid up to the second order, so there is no need to apply unscented transform - we won&rsquo;t be able to get better results with it.</p><h3 id=considering-4-th-order-terms>Considering 4-th order terms
<a class=heading-link href=#considering-4-th-order-terms><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>The derivation of higher terms of covariance update is presented in paper <sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>. Here I will just propagate the covariance while using their derivations.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#fff;font-weight:700>def</span> linOp(A):
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> -np.trace(A) * np.eye(<span style=color:#ff0;font-weight:700>3</span>) + A
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>def</span> linOpB(A, B):
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> linOp(A) @ linOp(B) + linOp(B @ A)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>T_next = T_0_true
</span></span><span style=display:flex><span>Sigma_next = np.zeros((<span style=color:#ff0;font-weight:700>6</span>, <span style=color:#ff0;font-weight:700>6</span>))
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> _ in <span style=color:#fff;font-weight:700>range</span>(<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>500</span>):
</span></span><span style=display:flex><span>    T_next = T_next @ T_move
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#007f7f># second-order term</span>
</span></span><span style=display:flex><span>    Ad_T1 = SE3.Ad(T_next)
</span></span><span style=display:flex><span>    Sigma_move_dash = Ad_T1 @ Sigma_move @ Ad_T1.T
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#007f7f># Temp variables</span>
</span></span><span style=display:flex><span>    Sigma1_PosPos = Sigma_next[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>]
</span></span><span style=display:flex><span>    Sigma1_PosPhi = Sigma_next[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>]
</span></span><span style=display:flex><span>    Sigma1_PhiPhi = Sigma_next[<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>]
</span></span><span style=display:flex><span>    Sigma2_PosPos = Sigma_move_dash[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>]
</span></span><span style=display:flex><span>    Sigma2_PosPhi = Sigma_move_dash[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>]
</span></span><span style=display:flex><span>    Sigma2_PhiPhi = Sigma_move_dash[<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#007f7f># third and fourth terms</span>
</span></span><span style=display:flex><span>    A1 = np.zeros((<span style=color:#ff0;font-weight:700>6</span>,<span style=color:#ff0;font-weight:700>6</span>))
</span></span><span style=display:flex><span>    A1[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>] = A1[<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>] = linOp(Sigma1_PhiPhi)
</span></span><span style=display:flex><span>    A1[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>] = linOp(Sigma1_PosPhi + Sigma1_PosPhi.T)
</span></span><span style=display:flex><span>    A2_dashed = np.zeros((<span style=color:#ff0;font-weight:700>6</span>,<span style=color:#ff0;font-weight:700>6</span>))
</span></span><span style=display:flex><span>    A2_dashed[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>] = A2_dashed[<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>] = linOp(Sigma2_PhiPhi)
</span></span><span style=display:flex><span>    A2_dashed[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>] = linOp(Sigma2_PosPhi + Sigma2_PosPhi.T)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    B_PosPos = linOpB(Sigma1_PhiPhi, Sigma2_PosPos) + linOpB(Sigma1_PosPhi.T, Sigma2_PosPhi)\
</span></span><span style=display:flex><span>        + linOpB(Sigma1_PosPhi, Sigma2_PosPhi.T) + linOpB(Sigma1_PosPos, Sigma2_PhiPhi)
</span></span><span style=display:flex><span>    B_PosPhi = linOpB(Sigma1_PhiPhi, Sigma2_PosPhi.T) + linOpB(Sigma1_PosPhi.T, Sigma2_PhiPhi)
</span></span><span style=display:flex><span>    B_PhiPhi = linOpB(Sigma1_PhiPhi, Sigma2_PhiPhi)
</span></span><span style=display:flex><span>    B = np.zeros((<span style=color:#ff0;font-weight:700>6</span>, <span style=color:#ff0;font-weight:700>6</span>))
</span></span><span style=display:flex><span>    B[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>] = B_PosPos
</span></span><span style=display:flex><span>    B[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>] = B_PosPhi
</span></span><span style=display:flex><span>    B[<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>,<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>3</span>] = B_PosPhi.T
</span></span><span style=display:flex><span>    B[<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>,<span style=color:#ff0;font-weight:700>3</span>:<span style=color:#ff0;font-weight:700>6</span>] = B_PhiPhi
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Sigma_next = Sigma_next + Sigma_move_dash\
</span></span><span style=display:flex><span>        + <span style=color:#ff0;font-weight:700>1</span>/<span style=color:#ff0;font-weight:700>12.0</span> * (A1 @ Sigma_move_dash + Sigma_move_dash @ A1.T 
</span></span><span style=display:flex><span>                    + A2_dashed @ Sigma_next + Sigma_next @ A2_dashed.T)\
</span></span><span style=display:flex><span>        + <span style=color:#ff0;font-weight:700>1</span>/<span style=color:#ff0;font-weight:700>4.0</span> * B
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>fig, ax = plt.subplots(<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>2</span>, figsize = (<span style=color:#ff0;font-weight:700>10</span>, <span style=color:#ff0;font-weight:700>5</span>))
</span></span><span style=display:flex><span>vis_distribution(fig, ax, np.zeros(<span style=color:#ff0;font-weight:700>6</span>), Sigma_next, np.linalg.inv(T_next), N = <span style=color:#ff0;font-weight:700>10000</span>)
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>print</span>(<span style=color:#0ff;font-weight:700>&#34;Covariance:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, Sigma_next[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>2</span>])
</span></span></code></pre></div><pre><code>Covariance:
 [[ 1858.357     0.   ]
 [    0.    49714.573]]
</code></pre><p><img src=uncertainty_prop_21_1.png#center alt=png></p><p>Bingo, now our uncertainty has much better shape, and we see that the higher order terms definitely helped us to end up with decent covariance that represents our true uncertainty more accurately and precise.</p><p>The usage of higher order terms is not always an option: first, the derivations are usually quite tricky and second, the computation complexity also increases.</p><h2 id=bonus>Bonus
<a class=heading-link href=#bonus><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In the last section I would like to compare the performance of vanilla-old Extended Kalman Filter for our toy-problem. Let&rsquo;s reformulate the problem: we have a robot that moves in one direction with perfectly known speed (1 m/s) and with slightly uncertain steering direction (as before, $2^\circ$). If our state $\mathbf{x}$ includes position and orientation, and our controls $\mathbf{u}$ are robot linear and angular speeds, we have the following state and control vectors:</p>$$
\mathbf{x} = \displaystyle \left[\begin{matrix}x & y & z & \phi & \theta & \psi\end{matrix}\right],
$$
$$
\mathbf{u} = \displaystyle \left[\begin{matrix}v_{x} & v_{y} & v_{z} & w_{x} & w_{y} & w_{z}\end{matrix}\right].
$$<p>and their dynamics have the following forms:</p>$$
\displaystyle \begin{bmatrix}\Delta{t} \left(v_{x} \cos{\left(\psi \right)} \cos{\left(\theta \right)} + v_{y} \left(\sin{\left(\phi \right)} \sin{\left(\theta \right)} \cos{\left(\psi \right)} - \sin{\left(\psi \right)} \cos{\left(\phi \right)}\right) + v_{z} \left(\sin{\left(\phi \right)} \sin{\left(\psi \right)} + \sin{\left(\theta \right)} \cos{\left(\phi \right)} \cos{\left(\psi \right)}\right)\right) + x \\\\ \Delta{t} \left(v_{x} \sin{\left(\psi \right)} \cos{\left(\theta \right)} + v_{y} \left(\sin{\left(\phi \right)} \sin{\left(\psi \right)} \sin{\left(\theta \right)} + \cos{\left(\phi \right)} \cos{\left(\psi \right)}\right) - v_{z} \left(\sin{\left(\phi \right)} \cos{\left(\psi \right)} - \sin{\left(\psi \right)} \sin{\left(\theta \right)} \cos{\left(\phi \right)}\right)\right) + y\\\\ \Delta{t} \left(- v_{x} \sin{\left(\theta \right)} + v_{y} \sin{\left(\phi \right)} \cos{\left(\theta \right)} + v_{z} \cos{\left(\phi \right)} \cos{\left(\theta \right)}\right) + z\\\\ \Delta{t} \left(w_{x} + w_{y} \sin{\left(\phi \right)} \tan{\left(\theta \right)} + w_{z} \cos{\left(\phi \right)} \tan{\left(\theta \right)}\right) + \phi\\\\ \Delta{t} \left(w_{y} \cos{\left(\phi \right)} - w_{z} \sin{\left(\phi \right)}\right) + \theta\\\\ \frac{\Delta{t} \left(w_{y} \sin{\left(\phi \right)} + w_{z} \cos{\left(\phi \right)}\right) + \psi \cos{\left(\theta \right)}}{\cos{\left(\theta \right)}}\end{bmatrix}
$$<p>Then we can find the Jacobians of state equations w.r.t. the state vector and controls and use the standard EKF equations for covariance propagation:</p>$$
\mathbf{P}_{i+1} = \mathbf{F}_i \mathbf{P}_i \mathbf{F}_{i}^T + \mathbf{G}_i \mathbf{U}_i \mathbf{G}_i^T.
$$<p>Now let&rsquo;s write the code and assess the covariance we end up with.</p><div class=spoiler><span class=spoilerText>Spoiler</span>
<input class=spoilerChecked type=checkbox showtext=Code><div class=spoilerContent><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>dt = <span style=color:#ff0;font-weight:700>1.0</span>
</span></span><span style=display:flex><span>sin, cos, tan  = np.sin, np.cos, np.tan
</span></span><span style=display:flex><span>v_x, v_y, v_z = <span style=color:#ff0;font-weight:700>1.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>
</span></span><span style=display:flex><span>w_x, w_y, w_z = <span style=color:#ff0;font-weight:700>0.0</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>P = np.zeros((<span style=color:#ff0;font-weight:700>6</span>, <span style=color:#ff0;font-weight:700>6</span>))
</span></span><span style=display:flex><span>x, y, z = <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>
</span></span><span style=display:flex><span>phi, theta, psi = <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> _ in <span style=color:#fff;font-weight:700>range</span>(<span style=color:#ff0;font-weight:700>0</span>, N_steps):
</span></span><span style=display:flex><span>    x = dt*(v_x*cos(psi)*cos(theta) + v_y*(sin(phi)*sin(theta)*cos(psi) - sin(psi)*cos(phi)) + v_z*(sin(phi)*sin(psi) + sin(theta)*cos(phi)*cos(psi))) + x
</span></span><span style=display:flex><span>    y = dt*(v_x*sin(psi)*cos(theta) + v_y*(sin(phi)*sin(psi)*sin(theta) + cos(phi)*cos(psi)) - v_z*(sin(phi)*cos(psi) - sin(psi)*sin(theta)*cos(phi))) + y
</span></span><span style=display:flex><span>    z = dt*(-v_x*sin(theta) + v_y*sin(phi)*cos(theta) + v_z*cos(phi)*cos(theta)) + z
</span></span><span style=display:flex><span>    phi = dt*(w_x + w_y*sin(phi)*tan(theta) + w_z*cos(phi)*tan(theta)) + phi
</span></span><span style=display:flex><span>    theta = dt*(w_y*cos(phi) - w_z*sin(phi)) + theta
</span></span><span style=display:flex><span>    psi = (dt*(w_y*sin(phi) + w_z*cos(phi)) + psi*cos(theta))/cos(theta)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#007f7f># Jacobian of state dynamics w.r.t. the state</span>
</span></span><span style=display:flex><span>    F_x = np.eye(<span style=color:#ff0;font-weight:700>6</span>)
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>3</span>] = dt*(v_y*(sin(phi)*sin(psi) + sin(theta)*cos(phi)*cos(psi)) - v_z*(sin(phi)*sin(theta)*cos(psi) - sin(psi)*cos(phi)))
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>4</span>] = dt*(-v_x*sin(theta) + v_y*sin(phi)*cos(theta) + v_z*cos(phi)*cos(theta))*cos(psi)
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>5</span>] = -dt*(v_x*sin(psi)*cos(theta) + v_y*(sin(phi)*sin(psi)*sin(theta) + cos(phi)*cos(psi)) - v_z*(sin(phi)*cos(psi) - sin(psi)*sin(theta)*cos(phi)))
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>3</span>] = -dt*(v_y*(sin(phi)*cos(psi) - sin(psi)*sin(theta)*cos(phi)) + v_z*(sin(phi)*sin(psi)*sin(theta) + cos(phi)*cos(psi)))
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>4</span>] = dt*(-v_x*sin(theta) + v_y*sin(phi)*cos(theta) + v_z*cos(phi)*cos(theta))*sin(psi)
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>5</span>] = dt*(v_x*cos(psi)*cos(theta) + v_y*(sin(phi)*sin(theta)*cos(psi) - sin(psi)*cos(phi)) + v_z*(sin(phi)*sin(psi) + sin(theta)*cos(phi)*cos(psi)))
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>3</span>] = dt*(v_y*cos(phi) - v_z*sin(phi))*cos(theta)
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>4</span>] = -dt*(v_x*cos(theta) + v_y*sin(phi)*sin(theta) + v_z*sin(theta)*cos(phi))
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>3</span>] = dt*(w_y*cos(phi) - w_z*sin(phi))*tan(theta) + <span style=color:#ff0;font-weight:700>1</span>
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>4</span>] = dt*(w_y*sin(phi) + w_z*cos(phi))/cos(theta)**<span style=color:#ff0;font-weight:700>2</span>
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>4</span>, <span style=color:#ff0;font-weight:700>3</span>] = -dt*(w_y*sin(phi) + w_z*cos(phi))
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>5</span>, <span style=color:#ff0;font-weight:700>3</span>] = dt*(w_y*cos(phi) - w_z*sin(phi))/cos(theta)
</span></span><span style=display:flex><span>    F_x[<span style=color:#ff0;font-weight:700>5</span>, <span style=color:#ff0;font-weight:700>4</span>] = dt*(w_y*sin(phi) + w_z*cos(phi))*sin(theta)/cos(theta)**<span style=color:#ff0;font-weight:700>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f># Jacobian of state w.r.t. the controls</span>
</span></span><span style=display:flex><span>    G_i = np.zeros((<span style=color:#ff0;font-weight:700>6</span>, <span style=color:#ff0;font-weight:700>6</span>))
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>0</span>] = dt*cos(psi)*cos(theta)
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>1</span>] = dt*(sin(phi)*sin(theta)*cos(psi) - sin(psi)*cos(phi))
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>2</span>] = dt*(sin(phi)*sin(psi) + sin(theta)*cos(phi)*cos(psi))
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>0</span>] = dt*sin(psi)*cos(theta)
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>1</span>] = dt*(sin(phi)*sin(psi)*sin(theta) + cos(phi)*cos(psi))
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>2</span>] = dt*(-sin(phi)*cos(psi) + sin(psi)*sin(theta)*cos(phi))
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>0</span>] = -dt*sin(theta)
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>1</span>] = dt*sin(phi)*cos(theta)
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>2</span>] = dt*cos(phi)*cos(theta)
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>3</span>] = dt
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>4</span>] = dt*sin(phi)*tan(theta)
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>5</span>] = dt*cos(phi)*tan(theta)
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>4</span>, <span style=color:#ff0;font-weight:700>4</span>] = dt*cos(phi)
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>4</span>, <span style=color:#ff0;font-weight:700>5</span>] = -dt*sin(phi)
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>5</span>, <span style=color:#ff0;font-weight:700>4</span>] = dt*sin(phi)/cos(theta)
</span></span><span style=display:flex><span>    G_i[<span style=color:#ff0;font-weight:700>5</span>, <span style=color:#ff0;font-weight:700>5</span>] = dt*cos(phi)/cos(theta)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Uc = np.diag([<span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.0</span>,
</span></span><span style=display:flex><span>                  <span style=color:#ff0;font-weight:700>0.</span>, <span style=color:#ff0;font-weight:700>0.</span>, sigma_direction_rad**<span style=color:#ff0;font-weight:700>2</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    P = F_x @ P @ F_x.T + G_i @ Uc @ G_i.T
</span></span></code></pre></div></div></div><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#fff;font-weight:700>print</span>(<span style=color:#0ff;font-weight:700>&#34;Covariance:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, Sigma_next[<span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>0</span>:<span style=color:#ff0;font-weight:700>2</span>])
</span></span></code></pre></div><pre><code>Covariance:
 [[ 1858.357     0.   ]
 [    0.    49714.573]]
</code></pre><p>We see that the result is the same. We got the same covariance using various methods. Do we have to bother to study and use Lie algebra if result is the same? It is interesting question and I try to leverage the answer in my next posts.</p><h1 id=references>References
<a class=heading-link href=#references><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://arxiv.org/abs/1812.01537 class=external-link target=_blank rel=noopener>https://arxiv.org/abs/1812.01537</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=http://asrl.utias.utoronto.ca/~tdb/bib/barfoot_ser17.pdf class=external-link target=_blank rel=noopener>http://asrl.utias.utoronto.ca/~tdb/bib/barfoot_ser17.pdf</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=http://paulfurgale.info/news/2014/6/9/representing-robot-pose-the-good-the-bad-and-the-ugly class=external-link target=_blank rel=noopener>http://paulfurgale.info/news/2014/6/9/representing-robot-pose-the-good-the-bad-and-the-ugly</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://gtsam.org/2021/02/23/uncertainties-part2.html class=external-link target=_blank rel=noopener>https://gtsam.org/2021/02/23/uncertainties-part2.html</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=http://www.roboticsproceedings.org/rss08/p34.pdf class=external-link target=_blank rel=noopener>http://www.roboticsproceedings.org/rss08/p34.pdf</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=http://ncfrn.mcgill.ca/members/pubs/barfoot_tro14.pdf class=external-link target=_blank rel=noopener>http://ncfrn.mcgill.ca/members/pubs/barfoot_tro14.pdf</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://hal.archives-ouvertes.fr/hal-01489204v3/document class=external-link target=_blank rel=noopener>https://hal.archives-ouvertes.fr/hal-01489204v3/document</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p><a href=https://arxiv.org/pdf/1906.07795.pdf class=external-link target=_blank rel=noopener>https://arxiv.org/pdf/1906.07795.pdf</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//mikoff-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2024
Aleksandr Mikoff
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>