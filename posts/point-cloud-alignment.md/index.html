<!doctype html><html lang=en><head><title>Point cloud alignment and SVD · Aleksandr Mikoff's blog
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Aleksandr Mikoff"><meta name=description content="Point cloud alignment and SVD Link to heading Singular value decomposition Link to heading Recently I studied the problem of finding the rotation and translation between two point sets and decided to write the post about it. The key here is singular value decomposition, or SVD.
It is extremely popular technique in many types of linear problems. It should be not surprised, that the point cloud alignment problem can be solved with its help."><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Point cloud alignment and SVD"><meta name=twitter:description content="Point cloud alignment and SVD Link to heading Singular value decomposition Link to heading Recently I studied the problem of finding the rotation and translation between two point sets and decided to write the post about it. The key here is singular value decomposition, or SVD.
It is extremely popular technique in many types of linear problems. It should be not surprised, that the point cloud alignment problem can be solved with its help."><meta property="og:title" content="Point cloud alignment and SVD"><meta property="og:description" content="Point cloud alignment and SVD Link to heading Singular value decomposition Link to heading Recently I studied the problem of finding the rotation and translation between two point sets and decided to write the post about it. The key here is singular value decomposition, or SVD.
It is extremely popular technique in many types of linear problems. It should be not surprised, that the point cloud alignment problem can be solved with its help."><meta property="og:type" content="article"><meta property="og:url" content="https://mikoff.github.io/posts/point-cloud-alignment.md/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-06-24T18:00:00+03:00"><meta property="article:modified_time" content="2020-06-24T18:00:00+03:00"><link rel=canonical href=https://mikoff.github.io/posts/point-cloud-alignment.md/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.577e3c5ead537873430da16f0964b754a120fd87c4e2203a00686e7c75b51378.css integrity="sha256-V348Xq1TeHNDDaFvCWS3VKEg/YfE4iA6AGhufHW1E3g=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/image.min.c1a5dfc6bac0eb1b85bcd8abf8aba0d18e0bf02fc972f9a0b17d2962f5ca8dd5.css integrity="sha256-waXfxrrA6xuFvNir+Kug0Y4L8C/JcvmgsX0pYvXKjdU=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/spoiler.min.bf901294afff95f520a8150a4df4249576eb9c49c4f40f5f9c2de750588dd594.css integrity="sha256-v5ASlK//lfUgqBUKTfQklXbrnEnE9A9fnC3nUFiN1ZQ=" crossorigin=anonymous media=screen><link rel=stylesheet href=/plugins/academic-icons/css/academicons.min.f6abb61f6b9b2e784eba22dfb93cd399ce30ee01825791830a2737d6bfcd2be9.css integrity="sha256-9qu2H2ubLnhOuiLfuTzTmc4w7gGCV5GDCic31r/NK+k=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://mikoff.github.io/>Aleksandr Mikoff's blog
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Posts</a></li><li class=navigation-item><a class=navigation-link href=/tags>Tags</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://mikoff.github.io/posts/point-cloud-alignment.md/>Point cloud alignment and SVD</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2020-06-24T18:00:00+03:00>June 24, 2020
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
7-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/point-cloud-alignment/>Point Cloud Alignment</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/svd/>SVD</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/pcl/>PCL</a></span></div></div></header><div class=post-content><h1 id=point-cloud-alignment-and-svd>Point cloud alignment and SVD
<a class=heading-link href=#point-cloud-alignment-and-svd><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><h2 id=singular-value-decomposition>Singular value decomposition
<a class=heading-link href=#singular-value-decomposition><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Recently I studied the problem of finding the rotation and translation between two point sets and decided to write the post about it. The key here is <em>singular value decomposition</em>, or SVD.</p><p>It is extremely popular technique in many types of linear problems. It should be not surprised, that the point cloud alignment problem can be solved with its help.
My aim here is to show all accommpanying theory and provide the point cloud alignment algorithm that takes not more than 10 lines of code in Python.</p><p>I would like to start from SVD.
It is convinient to think about any matrix as a function, action, or transformation $A$, that maps points $\vec{x} \in R^n$ to points $\vec{y} = A\vec{x} \in R^m$. Intuitively, we can raise the question: what happens to the geometry of $R^n$ after action $A$. If our initial column space $R^n$ is represented by orthonormal basis, that can be visualzed as a grid, then we ask the following questions: what happens with our grid&rsquo;s <em>squares</em> after transformation $A$.</p><p>Let&rsquo;s illustrate this problem with simple graphics.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#fff;font-weight:700>def</span> genRMatrix(theta):
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>def</span> transform(A, X, Y):
</span></span><span style=display:flex><span>    mult = A @ np.array([X.ravel(), Y.ravel()])
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> mult[<span style=color:#ff0;font-weight:700>0</span>,:].reshape(X.shape), mult[<span style=color:#ff0;font-weight:700>1</span>,:].reshape(Y.shape)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>def</span> visualise(ax, X, Y, title):
</span></span><span style=display:flex><span>    ax.scatter(X, Y)
</span></span><span style=display:flex><span>    ax.axis(<span style=color:#0ff;font-weight:700>&#34;equal&#34;</span>)
</span></span><span style=display:flex><span>    ax.set_xlim(-<span style=color:#ff0;font-weight:700>7</span>, <span style=color:#ff0;font-weight:700>7</span>)
</span></span><span style=display:flex><span>    ax.set_ylim(-<span style=color:#ff0;font-weight:700>7</span>, <span style=color:#ff0;font-weight:700>7</span>)
</span></span><span style=display:flex><span>    ax.set(adjustable=<span style=color:#0ff;font-weight:700>&#39;box&#39;</span>, aspect=<span style=color:#0ff;font-weight:700>&#39;equal&#39;</span>)
</span></span><span style=display:flex><span>    ax.set_title(title)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x = np.linspace(-<span style=color:#ff0;font-weight:700>5</span>, <span style=color:#ff0;font-weight:700>5</span>, <span style=color:#ff0;font-weight:700>11</span>)
</span></span><span style=display:flex><span>y = np.linspace(-<span style=color:#ff0;font-weight:700>5</span>, <span style=color:#ff0;font-weight:700>5</span>, <span style=color:#ff0;font-weight:700>11</span>)
</span></span><span style=display:flex><span>X, Y = np.meshgrid(x, y, sparse=<span style=color:#fff;font-weight:700>False</span>)
</span></span><span style=display:flex><span>fig, ax = plt.subplots(<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>4</span>, figsize = (<span style=color:#ff0;font-weight:700>24</span>, <span style=color:#ff0;font-weight:700>5</span>), subplot_kw=<span style=color:#fff;font-weight:700>dict</span>(aspect=<span style=color:#0ff;font-weight:700>&#39;equal&#39;</span>), 
</span></span><span style=display:flex><span>                       gridspec_kw=<span style=color:#fff;font-weight:700>dict</span>(width_ratios=[<span style=color:#ff0;font-weight:700>1</span>,<span style=color:#ff0;font-weight:700>1</span>,<span style=color:#ff0;font-weight:700>1</span>,<span style=color:#ff0;font-weight:700>1</span>]))
</span></span><span style=display:flex><span>visualise(ax[<span style=color:#ff0;font-weight:700>0</span>], X, Y, <span style=color:#0ff;font-weight:700>&#34;Initial grid $G$&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>alphaV = np.deg2rad(<span style=color:#ff0;font-weight:700>30</span>)
</span></span><span style=display:flex><span>VT = genRMatrix(alphaV).T
</span></span><span style=display:flex><span>XVT, YVT = transform(VT, X, Y)
</span></span><span style=display:flex><span>visualise(ax[<span style=color:#ff0;font-weight:700>1</span>], XVT, YVT, <span style=color:#0ff;font-weight:700>&#34;$G$ transformed by $V^T$&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>S = np.array([[<span style=color:#ff0;font-weight:700>0.5</span>, <span style=color:#ff0;font-weight:700>0</span>], [<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>0.75</span>]])
</span></span><span style=display:flex><span>XSVT, YSVT = transform(S @ VT, XVT, YVT)
</span></span><span style=display:flex><span>visualise(ax[<span style=color:#ff0;font-weight:700>2</span>], XSVT, YSVT, <span style=color:#0ff;font-weight:700>&#34;$G$ transformed by $\Sigma V^T$&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>alphaU = np.deg2rad(<span style=color:#ff0;font-weight:700>45</span>)
</span></span><span style=display:flex><span>U = genRMatrix(alphaU)
</span></span><span style=display:flex><span>A = USVT = U @ S @ VT
</span></span><span style=display:flex><span>XUSVT, YUSVT = transform(A, X, Y)
</span></span><span style=display:flex><span>visualise(ax[<span style=color:#ff0;font-weight:700>3</span>], XUSVT, YUSVT, <span style=color:#0ff;font-weight:700>&#34;$G$ transformed by $U \Sigma V^T$&#34;</span>)
</span></span></code></pre></div><p><img src=output_4_0.png alt=png></p><p>The SVD is very helpful because it is always exists for any matrix $A \in R^{m \times n}$. From geometric standpoint the SVD can be seen as a composition of isometry, followed by a scale in each coordinate axis and a second isometry. The isometry means that $U$ and $V$ are orthogonal: their action preserves lengths and the angles.</p><p>Let&rsquo;s solve the reverse problem: find the SVD factorization for our matrix $A$:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span>u, s, v = np.linalg.svd(A)
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>print</span>(<span style=color:#0ff;font-weight:700>&#34;U:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, u)
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>print</span>(<span style=color:#0ff;font-weight:700>&#34;S:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, s)
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>print</span>(<span style=color:#0ff;font-weight:700>&#34;V:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, v)
</span></span></code></pre></div><pre><code>U:
 [[-0.70710678  0.70710678]
 [ 0.70710678  0.70710678]]
S:
 [0.75 0.5 ]
V:
 [[-0.5        0.8660254]
 [ 0.8660254  0.5      ]]
</code></pre><p>We can note that the order is different. It happens because usually the math libraries return left and singular vectors $U$ and $V$, and the corresponding singular values in sorted order, such as $\sigma_1 \geq \sigma_2 \geq \dots \sigma_n \geq 0$.</p><h3 id=svd-computation>SVD computation
<a class=heading-link href=#svd-computation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>It is valuable to note why SVD computation is costly:</p><ul><li>The columns of $V$ are the eigenvectors of $A^T A$ (that can be computed, by example, using QR iteration).</li><li>Then, rewriting $A = U \Sigma V^T$ as $AV = U \Sigma$ we can make the observation that the columns of $U$ corresponding to $\sigma_i \neq 0$ are normalized columns of $AV$.</li><li>The remaining columns satisfy the following property: $AA^T\vec{u}_i = 0$. They can be computed through LU factorization.</li></ul><h2 id=point-cloud-alignment-the-procrustes-problem>Point cloud alignment, the Procrustes problem
<a class=heading-link href=#point-cloud-alignment-the-procrustes-problem><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The problem of the shape alignment arises quite often in computer vision problems. For example, we can have the lidar scan results that consist of two point clouds of the same object from different views. A task here is to align these points, or to find the rotation matrix $R$ and translation $\vec{t}$ that align one point set to another. It is assumed that the points correspondences are known (in our case - the corresponding points have the same indices).</p><p>Mathematically, this problem can be formulated in the following way:</p><ul><li>Having $n$ overlapping points from two point clouds we can store them in two matrices $X_1, X_2 \in R^{m \times n}$, where $m$ is the number of degrees of freedom of the point.</li><li>Then, for each point $x_{1i}$ of $X_1$ and $x_{2i}$ of $X_2$ the following equality should hold:
$$R \vec{x}_{1i} + \vec{t} = \vec{x}_{2i}$$</li><li>Because of the errors, the following energy function should be minimized:
$$E(R, \vec{t}) = \sum_{i} || R \vec{x}_{1i} + \vec{t} - \vec{x}_{2i}||^2.$$</li><li>The minimum of the objective function can be found by taking the derivative w.r.t. $R$ and $\vec{t}$.</li></ul><h2 id=translational-component>Translational component
<a class=heading-link href=#translational-component><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To find the optimal $\vec{t}$ value we have to fix $R$ and find the derivative w.r.t. $\vec{t}$:</p>$$
\begin{array}{c}
\sum_{i} || R \vec{x}_{1i} + \vec{t} - \vec{x}_{2i}||^2 = \\\\
= \sum_{i} (R \vec{x}_{1i} + \vec{t} - \vec{x}_{2i}) \cdot (R \vec{x}_{1i} + \vec{t} - \vec{x}_{2i}) \\\\
= \sum_{i} (R \vec{x}_{1i} + \vec{t} - \vec{x}_{2i})^T (R \vec{x}_{1i} + \vec{t} - \vec{x}_{2i}) = \\\\
= \sum_{i} (\vec{x}_{2i}^T R^T R \vec{x}_{1i} + \vec{x}_{1i}^T R^T \vec{t} - \vec{x}_{1i}^T R^T \vec{x}_{2i} + \vec{t} R \vec{x}_{1i} + \vec{t}^T \vec{t} - \vec{t} \vec{x}_{2i} - \vec{2}_{1i}^T R \vec{x}_{1i} - \vec{x}_{2i}^T \vec{t} + \vec{x}_{2i}^T \vec{x}_{2i})
\end{array}
$$<p>The gradient of this expression w.r.t. $\vec{t}$ must be zero at the minimum, therefore, dropping out the terms, do not depending on $\vec{t}$ we have:</p>$$
\begin{array}{c}
\frac{\delta E}{\delta \vec{t}} = \frac{\delta}{\delta \vec{t}}\sum_{i} (2 \vec{t}^T R \vec{x}_{1i} - 2 \vec{t}^T \vec{x}_{2i} + \vec{t}^T \vec{t}) = \\\\
= \sum_{i} (2 R \vec{x}_{1i} - 2 \vec{x}_{2i} + 2 \vec{t}) = \\\\
= 2 n\vec{t} + \sum_{i}(2 R \vec{x}_{1i} - 2\vec{x}_{2i}) = \\\\
= n\vec{t} + \sum_{i}(R \vec{x}_{1i} - \vec{x}_{2i})
\end{array}
$$<p>The critical point can be found by setting the gradient to zero:</p>$$
\begin{array}{c}
n\vec{t} + \sum_{i}(R \vec{x}_{1i} - \vec{x}_{2i}) = 0 \\\\
n\vec{t} = \sum_{i}(\vec{x}_{2i} - R \vec{x}_{1i}) \\\\
n\vec{t} = \sum_{i}(\vec{x}_{2i} - R \vec{x}_{1i}) \\\\
\vec{t} = \frac{\sum_{i}(\vec{x}_{2i} - R \vec{x}_{1i})}{n}
\end{array}
$$<h2 id=rotational-component>Rotational component
<a class=heading-link href=#rotational-component><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>To find the optimal $R$ we have to fix $\vec{t}$ and find the $R$ subject to constraint that $R$ is an orthogonal matrix: $R^T R = I_{3}$. See the detailed description and the derivation of the problem solution <a href=https://simonensemble.github.io/2018-10-27-orthogonal-procrustes/ class=external-link target=_blank rel=noopener>here</a>.</p><p>The orthogonal matrix $R$ minimizing the $||RX - Y||^2$ is given by $V U^T$, where SVD is applied to find out $XY^T = U\Sigma V^T$.</p><h2 id=alternation>Alternation
<a class=heading-link href=#alternation><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Now, knowing how both the components can be found, one of the most typical strategies is the alternation (that is used in EM algorithm, clustering method and other iterative algorithms):</p><ol><li>Fix $R$ and minimize $E$ w.r.t. $\vec{t}$.</li><li>Fix the newly found $\vec{t}$ and minimize $E$ w.r.t. $R$ under $R^T R = I_3$ constraint.</li><li>Go to step 1 until convergence.</li></ol><p>Since in this procedure the $R$ and $\vec{t}$ are not optimized simultaneously, there is no guarantee that we reach the globally optimal solution, but in practice it works well.</p><h2 id=example>Example
<a class=heading-link href=#example><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Suppose we have a set of 2d points $X_1$, and let&rsquo;s rotate and translate them randomly, generating point set $X_2$:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#007f7f># generate points for X1 set</span>
</span></span><span style=display:flex><span>x1part1 = np.array([[<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>0</span>], [<span style=color:#ff0;font-weight:700>4</span>, <span style=color:#ff0;font-weight:700>4</span>], [<span style=color:#ff0;font-weight:700>4</span>, <span style=color:#ff0;font-weight:700>0</span>], [<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>4</span>], [<span style=color:#ff0;font-weight:700>2.</span>, <span style=color:#ff0;font-weight:700>6.</span>], [<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>1</span>], [<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>3</span>], [<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>3</span>], [<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>1</span>]]).T
</span></span><span style=display:flex><span>thetas = np.linspace(<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>2</span> * np.pi, <span style=color:#ff0;font-weight:700>24</span>)
</span></span><span style=display:flex><span>x1part2 = np.vstack([np.sin(thetas) * <span style=color:#ff0;font-weight:700>3</span> + <span style=color:#ff0;font-weight:700>8</span>, np.cos(thetas) * <span style=color:#ff0;font-weight:700>3</span> + <span style=color:#ff0;font-weight:700>2</span>])
</span></span><span style=display:flex><span>x1part3 = np.vstack([np.sin(thetas) * <span style=color:#ff0;font-weight:700>4</span> + <span style=color:#ff0;font-weight:700>12</span>, np.cos(thetas) * <span style=color:#ff0;font-weight:700>3</span> + <span style=color:#ff0;font-weight:700>4</span>])
</span></span><span style=display:flex><span>X1 = np.hstack([x1part1, x1part2, x1part3])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f># randomly pick angle and translation</span>
</span></span><span style=display:flex><span>rotationAngle = np.deg2rad(np.random.randint(-<span style=color:#ff0;font-weight:700>180</span>, <span style=color:#ff0;font-weight:700>180</span>, <span style=color:#ff0;font-weight:700>1</span>)[<span style=color:#ff0;font-weight:700>0</span>])
</span></span><span style=display:flex><span>rotation = genRMatrix(rotationAngle)
</span></span><span style=display:flex><span>translation = np.random.randint(-<span style=color:#ff0;font-weight:700>10</span>, <span style=color:#ff0;font-weight:700>10</span>, <span style=color:#ff0;font-weight:700>2</span>).reshape((<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f># rotate our original point set X1</span>
</span></span><span style=display:flex><span>X2 = rotation @ X1 + translation
</span></span></code></pre></div><p>Our alternation step for $R$ and $t$ estimation is defined in <code>pointCloudAlignmentStep</code> function, the residual calculation between two point clouds, that is used as termination condition - in <code>pointCloudResidual</code> function.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#fff;font-weight:700>def</span> pointCloudAlignmentStep(R, t, X1, X2):
</span></span><span style=display:flex><span>    foundTransl = np.mean((X2 - R @ X1), axis=<span style=color:#ff0;font-weight:700>1</span>).reshape((<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>1</span>))
</span></span><span style=display:flex><span>    u, s, v = np.linalg.svd(X1 @ (X2 - foundTransl).T)
</span></span><span style=display:flex><span>    foundRot = v @ u.T
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> foundRot, foundTransl
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>def</span> pointCloudResidual(R, t, X1, X2):
</span></span><span style=display:flex><span>    X2f = R @ X1 + t
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> np.linalg.norm(X2 - X2f)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#007f7f># initial values</span>
</span></span><span style=display:flex><span>R = np.eye(<span style=color:#ff0;font-weight:700>2</span>)
</span></span><span style=display:flex><span>t = np.zeros((<span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>1</span>))
</span></span><span style=display:flex><span>MIN_RESIDUAL_TO_TERMINATE = <span style=color:#ff0;font-weight:700>1e-8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f># find the translation and rotation between two point clouds iteratively</span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>while</span> pointCloudResidual(R, t, X1, X2) &gt; MIN_RESIDUAL_TO_TERMINATE:
</span></span><span style=display:flex><span>    R, t = pointCloudAlignmentStep(R, t, X1, X2)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>print</span>(<span style=color:#0ff;font-weight:700>&#34;True rotation and translation between point sets.</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>R:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, rotation, <span style=color:#0ff;font-weight:700>&#34;</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>t:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, translation)
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>print</span>(<span style=color:#0ff;font-weight:700>&#34;Estimated rotation and translation between point sets.</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>R:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, R, <span style=color:#0ff;font-weight:700>&#34;</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>t:</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>, t)
</span></span></code></pre></div><pre><code>True rotation and translation between point sets.
R:
 [[ 0.98162718  0.190809  ]
 [-0.190809    0.98162718]] 
t:
 [[9]
 [7]]
Estimated rotation and translation between point sets.
R:
 [[ 0.98162718  0.190809  ]
 [-0.190809    0.98162718]] 
t:
 [[9.]
 [7.]]
</code></pre><p>In the end let&rsquo;s visialize the algorithm actions:<div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/8_DBYDAuQF0 style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div></p><p>If you are interested in more complex topic or want to find the ready-to-use solution for your problem do not forget to check <a href=https://pointclouds.org/ class=external-link target=_blank rel=noopener>Point Cloud Library</a>.</p><p>The jupyter notebook is available <a href=https://github.com/mikoff/blog_projects/tree/master/notebooks/Point_cloud_alignment_and_SVD class=external-link target=_blank rel=noopener>here</a>.</p></div><footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//mikoff-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}(),document.addEventListener("themeChanged",function(){document.readyState=="complete"&&DISQUS.reset({reload:!0,config:disqus_config})})</script></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2024
Aleksandr Mikoff
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>